{
  "method_name": "create_kx_cluster",
  "url": "https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/finspace/client/create_kx_cluster.html",
  "description": "Creates a new kdb cluster.",
  "parameters": [
    {
      "name": "clientToken",
      "type": "string",
      "required": false,
      "description": "A token that ensures idempotency. This token expires in 10 minutes. This field is autopopulated if not provided.",
      "nested_params": []
    },
    {
      "name": "environmentId",
      "type": "string",
      "required": true,
      "description": "A unique identifier for the kdb environment.",
      "nested_params": []
    },
    {
      "name": "clusterName",
      "type": "string",
      "required": true,
      "description": "A unique name for the cluster that you want to create.",
      "nested_params": []
    },
    {
      "name": "clusterType",
      "type": "string",
      "required": true,
      "description": "Specifies the type of KDB database that is being created. The following types are available: HDB --- A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster. RDB --- A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter. GATEWAY --- A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage. GP --- A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode. Tickerplant --- A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.",
      "nested_params": []
    },
    {
      "name": "tickerplantLogConfiguration",
      "type": "dict",
      "required": false,
      "description": "A configuration to store Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path. tickerplantLogVolumes (list) --- The name of the volumes for tickerplant logs. (string) ---",
      "nested_params": [
        {
          "name": "tickerplantLogVolumes",
          "type": "list",
          "required": false,
          "description": "The name of the volumes for tickerplant logs.",
          "nested_params": []
        }
      ]
    },
    {
      "name": "databases",
      "type": "list",
      "required": true,
      "description": "A list of databases that will be available for querying. (dict) --- The configuration of data that is available for querying from this database. The name of the kdb database. When this parameter is specified in the structure, S3 with the whole database is included by default. cacheConfigurations (list) --- Configuration details for the disk cache used to increase performance reading from a kdb database mounted to the cluster. (dict) --- The structure of database cache configuration that is used for mapping database paths to cache types in clusters. The type of disk cache. This parameter is used to map the database path to cache storage. The valid values are: CACHE_1000 --- This type provides at least 1000 MB/s disk access throughput. Specifies the portions of database that will be loaded into the cache for access. (string) --- dataviewName (string) --- The name of the dataview to be used for caching historical data on disk. changesetId (string) --- A unique identifier of the changeset that is associated with the cluster. dataviewName (string) --- The name of the dataview to be used for caching historical data on disk. dataviewConfiguration (dict) --- The configuration of the dataview to be used with specified cluster. dataviewName (string) --- The unique identifier of the dataview. dataviewVersionId (string) --- The version of the dataview corresponding to a given changeset. changesetId (string) --- A unique identifier for the changeset. segmentConfigurations (list) --- The db path and volume configuration for the segmented database. (dict) --- The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. The database path of the data that you want to place on each selected volume for the segment. (string) --- The name of the volume where you want to add data. onDemand (boolean) --- Enables on-demand caching on the selected database path when a particular file or a column of the database is accessed. When on demand caching is True, dataviews perform minimal loading of files on the filesystem as needed. When it is set to False, everything is cached. The default value is False.",
      "nested_params": [
        {
          "name": "databaseName",
          "type": "string",
          "required": false,
          "description": "The name of the kdb database. When this parameter is specified in the structure, S3 with the whole database is included by default.",
          "nested_params": []
        },
        {
          "name": "cacheConfigurations",
          "type": "list",
          "required": false,
          "description": "Configuration details for the disk cache used to increase performance reading from a kdb database mounted to the cluster.",
          "nested_params": [
            {
              "name": "cacheType",
              "type": "string",
              "required": false,
              "description": "The type of disk cache. This parameter is used to map the database path to cache storage. The valid values are:",
              "nested_params": []
            },
            {
              "name": "dbPaths",
              "type": "list",
              "required": false,
              "description": "Specifies the portions of database that will be loaded into the cache for access.",
              "nested_params": []
            },
            {
              "name": "dataviewName",
              "type": "string",
              "required": false,
              "description": "The name of the dataview to be used for caching historical data on disk.",
              "nested_params": []
            }
          ]
        },
        {
          "name": "changesetId",
          "type": "string",
          "required": false,
          "description": "A unique identifier of the changeset that is associated with the cluster.",
          "nested_params": []
        },
        {
          "name": "dataviewName",
          "type": "string",
          "required": false,
          "description": "The name of the dataview to be used for caching historical data on disk.",
          "nested_params": []
        },
        {
          "name": "dataviewConfiguration",
          "type": "dict",
          "required": false,
          "description": "The configuration of the dataview to be used with specified cluster.",
          "nested_params": [
            {
              "name": "dataviewName",
              "type": "string",
              "required": false,
              "description": "The unique identifier of the dataview.",
              "nested_params": []
            },
            {
              "name": "dataviewVersionId",
              "type": "string",
              "required": false,
              "description": "The version of the dataview corresponding to a given changeset.",
              "nested_params": []
            },
            {
              "name": "changesetId",
              "type": "string",
              "required": false,
              "description": "A unique identifier for the changeset.",
              "nested_params": []
            },
            {
              "name": "segmentConfigurations",
              "type": "list",
              "required": false,
              "description": "The db path and volume configuration for the segmented database.",
              "nested_params": [
                {
                  "name": "dbPaths",
                  "type": "list",
                  "required": false,
                  "description": "The database path of the data that you want to place on each selected volume for the segment. Each segment must have a unique database path for each volume.",
                  "nested_params": []
                },
                {
                  "name": "volumeName",
                  "type": "string",
                  "required": false,
                  "description": "The name of the volume where you want to add data.",
                  "nested_params": []
                },
                {
                  "name": "onDemand",
                  "type": "boolean",
                  "required": false,
                  "description": "",
                  "nested_params": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "cacheStorageConfigurations",
      "type": "list",
      "required": true,
      "description": "The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store. (dict) --- The configuration for read only disk cache associated with a cluster. The type of cache storage. The valid values are: CACHE_1000 --- This type provides at least 1000 MB/s disk access throughput. CACHE_250 --- This type provides at least 250 MB/s disk access throughput. CACHE_12 --- This type provides at least 12 MB/s disk access throughput. For cache type CACHE_1000 and CACHE_250 you can select cache size as 1200 GB or increments of 2400 GB. For cache type CACHE_12 you can select the cache size in increments of 6000 GB. The size of cache in Gigabytes.",
      "nested_params": [
        {
          "name": "type",
          "type": "string",
          "required": false,
          "description": "The type of cache storage. The valid values are:",
          "nested_params": []
        },
        {
          "name": "size",
          "type": "integer",
          "required": false,
          "description": "The size of cache in Gigabytes.",
          "nested_params": []
        }
      ]
    },
    {
      "name": "autoScalingConfiguration",
      "type": "dict",
      "required": false,
      "description": "The configuration based on which FinSpace will scale in or scale out nodes in your cluster. minNodeCount (integer) --- The lowest number of nodes to scale. This value must be at least 1 and less than the maxNodeCount. If the nodes in a cluster belong to multiple availability zones, then minNodeCount must be at least 3. maxNodeCount (integer) --- The highest number of nodes to scale. This value cannot be greater than 5. autoScalingMetric (string) --- The metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all the nodes in a cluster. metricTarget (float) --- The desired value of the chosen autoScalingMetric. When the metric drops below this value, the cluster will scale in. When the metric goes above this value, the cluster will scale out. You can set the target value between 1 and 100 percent. scaleInCooldownSeconds (float) --- The duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event. scaleOutCooldownSeconds (float) --- The duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.",
      "nested_params": [
        {
          "name": "minNodeCount",
          "type": "integer",
          "required": false,
          "description": "The lowest number of nodes to scale. This value must be at least 1 and less than the maxNodeCount. If the nodes in a cluster belong to multiple availability zones, then minNodeCount must be at least 3.",
          "nested_params": []
        },
        {
          "name": "maxNodeCount",
          "type": "integer",
          "required": false,
          "description": "The highest number of nodes to scale. This value cannot be greater than 5.",
          "nested_params": []
        },
        {
          "name": "autoScalingMetric",
          "type": "string",
          "required": false,
          "description": "The metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all the nodes in a cluster.",
          "nested_params": []
        },
        {
          "name": "metricTarget",
          "type": "float",
          "required": false,
          "description": "The desired value of the chosen autoScalingMetric. When the metric drops below this value, the cluster will scale in. When the metric goes above this value, the cluster will scale out. You can set the target value between 1 and 100 percent.",
          "nested_params": []
        },
        {
          "name": "scaleInCooldownSeconds",
          "type": "float",
          "required": false,
          "description": "The duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event.",
          "nested_params": []
        },
        {
          "name": "scaleOutCooldownSeconds",
          "type": "float",
          "required": false,
          "description": "The duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.",
          "nested_params": []
        }
      ]
    },
    {
      "name": "clusterDescription",
      "type": "string",
      "required": false,
      "description": "",
      "nested_params": []
    },
    {
      "name": "capacityConfiguration",
      "type": "dict",
      "required": false,
      "description": "A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances. nodeType (string) --- The type that determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance. You can only specify one of the following values: kx.s.large --- The node type with a configuration of 12 GiB memory and 2 vCPUs. kx.s.xlarge --- The node type with a configuration of 27 GiB memory and 4 vCPUs. kx.s.2xlarge --- The node type with a configuration of 54 GiB memory and 8 vCPUs. kx.s.4xlarge --- The node type with a configuration of 108 GiB memory and 16 vCPUs. kx.s.8xlarge --- The node type with a configuration of 216 GiB memory and 32 vCPUs. kx.s.16xlarge --- The node type with a configuration of 432 GiB memory and 64 vCPUs. kx.s.32xlarge --- The node type with a configuration of 864 GiB memory and 128 vCPUs. nodeCount (integer) --- The number of instances running in a cluster.",
      "nested_params": [
        {
          "name": "nodeType",
          "type": "string",
          "required": false,
          "description": "The type that determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance. You can only specify one of the following values:",
          "nested_params": []
        },
        {
          "name": "nodeCount",
          "type": "integer",
          "required": false,
          "description": "The number of instances running in a cluster.",
          "nested_params": []
        }
      ]
    },
    {
      "name": "releaseLabel",
      "type": "string",
      "required": true,
      "description": "The version of FinSpace managed kdb to run.",
      "nested_params": []
    },
    {
      "name": "vpcConfiguration",
      "type": "dict",
      "required": true,
      "description": "Configuration details about the network where the Privatelink endpoint of the cluster resides. vpcId (string) --- The identifier of the VPC endpoint. securityGroupIds (list) --- The unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster. (string) --- subnetIds (list) --- The identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster. (string) --- ipAddressType (string) --- The IP address type for cluster network configuration parameters. The following type is available: IP_V4 --- IP address version 4",
      "nested_params": [
        {
          "name": "vpcId",
          "type": "string",
          "required": false,
          "description": "The identifier of the VPC endpoint.",
          "nested_params": []
        },
        {
          "name": "securityGroupIds",
          "type": "list",
          "required": false,
          "description": "The unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster.",
          "nested_params": []
        },
        {
          "name": "subnetIds",
          "type": "list",
          "required": false,
          "description": "The identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster.",
          "nested_params": []
        },
        {
          "name": "ipAddressType",
          "type": "string",
          "required": false,
          "description": "The IP address type for cluster network configuration parameters. The following type is available:",
          "nested_params": []
        }
      ]
    },
    {
      "name": "initializationScript",
      "type": "string",
      "required": false,
      "description": "",
      "nested_params": []
    },
    {
      "name": "commandLineArguments",
      "type": "list",
      "required": false,
      "description": "Defines the key-value pairs to make them available inside the cluster. (dict) --- Defines the key-value pairs to make them available inside the cluster. key (string) --- The name of the key. value (string) --- The value of the key.",
      "nested_params": [
        {
          "name": "key",
          "type": "string",
          "required": false,
          "description": "The name of the key.",
          "nested_params": []
        },
        {
          "name": "value",
          "type": "string",
          "required": false,
          "description": "The value of the key.",
          "nested_params": []
        }
      ]
    },
    {
      "name": "code",
      "type": "dict",
      "required": false,
      "description": "The details of the custom code that you want to use inside a cluster when analyzing a data. It consists of the S3 source bucket, location, S3 object version, and the relative path from where the custom code is loaded into the cluster. s3Bucket (string) --- A unique name for the S3 bucket. s3Key (string) --- The full S3 path (excluding bucket) to the .zip file. This file contains the code that is loaded onto the cluster when it's started. s3ObjectVersion (string) --- The version of an S3 object.",
      "nested_params": [
        {
          "name": "s3Bucket",
          "type": "string",
          "required": false,
          "description": "A unique name for the S3 bucket.",
          "nested_params": []
        },
        {
          "name": "s3Key",
          "type": "string",
          "required": false,
          "description": "The full S3 path (excluding bucket) to the .zip file. This file contains the code that is loaded onto the cluster when it's started.",
          "nested_params": []
        },
        {
          "name": "s3ObjectVersion",
          "type": "string",
          "required": false,
          "description": "The version of an S3 object.",
          "nested_params": []
        }
      ]
    },
    {
      "name": "executionRole",
      "type": "string",
      "required": false,
      "description": "",
      "nested_params": []
    },
    {
      "name": "savedownStorageConfiguration",
      "type": "dict",
      "required": false,
      "description": "The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted. type (string) --- The type of writeable storage space for temporarily storing your savedown data. The valid values are: SDS01 --- This type represents 3000 IOPS and io2 ebs volume type. size (integer) --- The size of temporary storage in gibibytes. volumeName (string) --- The name of the kdb volume that you want to use as writeable save-down storage for clusters.",
      "nested_params": [
        {
          "name": "type",
          "type": "string",
          "required": false,
          "description": "The type of writeable storage space for temporarily storing your savedown data. The valid values are:",
          "nested_params": []
        },
        {
          "name": "size",
          "type": "integer",
          "required": false,
          "description": "The size of temporary storage in gibibytes.",
          "nested_params": []
        },
        {
          "name": "volumeName",
          "type": "string",
          "required": false,
          "description": "The name of the kdb volume that you want to use as writeable save-down storage for clusters.",
          "nested_params": []
        }
      ]
    },
    {
      "name": "azMode",
      "type": "string",
      "required": true,
      "description": "The number of availability zones you want to assign per cluster. This can be one of the following SINGLE --- Assigns one availability zone per cluster. MULTI --- Assigns all the availability zones per cluster.",
      "nested_params": []
    },
    {
      "name": "availabilityZoneId",
      "type": "string",
      "required": false,
      "description": "",
      "nested_params": []
    },
    {
      "name": "tags",
      "type": "dict",
      "required": false,
      "description": "A list of key-value pairs to label the cluster. You can add up to 50 tags to a cluster. (string) --- (string) ---",
      "nested_params": []
    },
    {
      "name": "scalingGroupConfiguration",
      "type": "dict",
      "required": true,
      "description": "The structure that stores the configuration details of a scaling group. A unique identifier for the kdb scaling group. memoryLimit (integer) --- An optional hard limit on the amount of memory a kdb cluster can use. A reservation of the minimum amount of memory that should be available on the scaling group for a kdb cluster to be successfully placed in a scaling group. The number of kdb cluster nodes. cpu (float) --- The number of vCPUs that you want to reserve for each node of this kdb cluster on the scaling group host.",
      "nested_params": [
        {
          "name": "scalingGroupName",
          "type": "string",
          "required": false,
          "description": "A unique identifier for the kdb scaling group.",
          "nested_params": []
        },
        {
          "name": "memoryLimit",
          "type": "integer",
          "required": false,
          "description": "An optional hard limit on the amount of memory a kdb cluster can use.",
          "nested_params": []
        },
        {
          "name": "memoryReservation",
          "type": "integer",
          "required": false,
          "description": "A reservation of the minimum amount of memory that should be available on the scaling group for a kdb cluster to be successfully placed in a scaling group.",
          "nested_params": []
        },
        {
          "name": "nodeCount",
          "type": "integer",
          "required": false,
          "description": "The number of kdb cluster nodes.",
          "nested_params": []
        },
        {
          "name": "cpu",
          "type": "float",
          "required": false,
          "description": "The number of vCPUs that you want to reserve for each node of this kdb cluster on the scaling group host.",
          "nested_params": []
        }
      ]
    }
  ],
  "return_structure": [
    {
      "name": "",
      "type": "dict",
      "description": "",
      "nested_items": [
        {
          "name": "environmentId",
          "type": "string",
          "description": "A unique identifier for the kdb environment.",
          "nested_items": []
        },
        {
          "name": "status",
          "type": "string",
          "description": "The status of cluster creation.",
          "nested_items": [
            {
              "name": "",
              "type": "",
              "description": "PENDING --- The cluster is pending creation.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "CREATING --- The cluster creation process is in progress.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "CREATE_FAILED --- The cluster creation process has failed.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "RUNNING --- The cluster creation process is running.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "UPDATING --- The cluster is in the process of being updated.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "DELETING --- The cluster is in the process of being deleted.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "DELETED --- The cluster has been deleted.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "DELETE_FAILED --- The cluster failed to delete.",
              "nested_items": []
            }
          ]
        },
        {
          "name": "statusReason",
          "type": "string",
          "description": "The error message when a failed state occurs.",
          "nested_items": []
        },
        {
          "name": "clusterName",
          "type": "string",
          "description": "A unique name for the cluster.",
          "nested_items": []
        },
        {
          "name": "clusterType",
          "type": "string",
          "description": "Specifies the type of KDB database that is being created. The following types are available:",
          "nested_items": [
            {
              "name": "",
              "type": "",
              "description": "HDB --- A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "RDB --- A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the savedownStorageConfiguration parameter.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "GATEWAY --- A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "GP --- A general purpose cluster allows you to quickly iterate on code during development by granting greater access to system commands and enabling a fast reload of custom code. This cluster type can optionally mount databases including cache and savedown storage. For this cluster type, the node count is fixed at 1. It does not support autoscaling and supports only SINGLE AZ mode.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "RTS",
              "description": "Tickerplant --- A tickerplant cluster allows you to subscribe to feed handlers based on IAM permissions. It can publish to RDBs, other Tickerplants, and real-time subscribers (RTS). Tickerplants can persist messages to log, which is readable by any RDB environment. It supports only single-node that is only one kdb process.",
              "nested_items": []
            }
          ]
        },
        {
          "name": "tickerplantLogConfiguration",
          "type": "dict",
          "description": "A configuration to store the Tickerplant logs. It consists of a list of volumes that will be mounted to your cluster. For the cluster type Tickerplant, the location of the TP volume on the cluster will be available by using the global variable .aws.tp_log_path.",
          "nested_items": [
            {
              "name": "tickerplantLogVolumes",
              "type": "list",
              "description": "The name of the volumes for tickerplant logs.",
              "nested_items": [
                {
                  "name": "",
                  "type": "string",
                  "description": "(string) ---",
                  "nested_items": []
                }
              ]
            }
          ]
        },
        {
          "name": "volumes",
          "type": "list",
          "description": "A list of volumes mounted on the cluster.",
          "nested_items": [
            {
              "name": "",
              "type": "dict",
              "description": "",
              "nested_items": [
                {
                  "name": "volumeName",
                  "type": "string",
                  "description": "A unique identifier for the volume.",
                  "nested_items": []
                },
                {
                  "name": "volumeType",
                  "type": "string",
                  "description": "The type of file system volume. Currently, FinSpace only supports NAS_1 volume type.",
                  "nested_items": []
                }
              ]
            }
          ]
        },
        {
          "name": "databases",
          "type": "list",
          "description": "A list of databases that will be available for querying.",
          "nested_items": [
            {
              "name": "",
              "type": "dict",
              "description": "",
              "nested_items": [
                {
                  "name": "databaseName",
                  "type": "string",
                  "description": "The name of the kdb database. When this parameter is specified in the structure, S3 with the whole database is included by default.",
                  "nested_items": []
                },
                {
                  "name": "cacheConfigurations",
                  "type": "list",
                  "description": "Configuration details for the disk cache used to increase performance reading from a kdb database mounted to the cluster.",
                  "nested_items": [
                    {
                      "name": "",
                      "type": "dict",
                      "description": "",
                      "nested_items": [
                        {
                          "name": "cacheType",
                          "type": "string",
                          "description": "The type of disk cache. This parameter is used to map the database path to cache storage. The valid values are:",
                          "nested_items": [
                            {
                              "name": "",
                              "type": "",
                              "description": "CACHE_1000 --- This type provides at least 1000 MB/s disk access throughput.",
                              "nested_items": []
                            }
                          ]
                        },
                        {
                          "name": "dbPaths",
                          "type": "list",
                          "description": "Specifies the portions of database that will be loaded into the cache for access.",
                          "nested_items": [
                            {
                              "name": "",
                              "type": "string",
                              "description": "(string) ---",
                              "nested_items": []
                            }
                          ]
                        },
                        {
                          "name": "dataviewName",
                          "type": "string",
                          "description": "The name of the dataview to be used for caching historical data on disk.",
                          "nested_items": []
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "changesetId",
                  "type": "string",
                  "description": "A unique identifier of the changeset that is associated with the cluster.",
                  "nested_items": []
                },
                {
                  "name": "dataviewName",
                  "type": "string",
                  "description": "The name of the dataview to be used for caching historical data on disk.",
                  "nested_items": []
                },
                {
                  "name": "dataviewConfiguration",
                  "type": "dict",
                  "description": "The configuration of the dataview to be used with specified cluster.",
                  "nested_items": [
                    {
                      "name": "dataviewName",
                      "type": "string",
                      "description": "The unique identifier of the dataview.",
                      "nested_items": []
                    },
                    {
                      "name": "dataviewVersionId",
                      "type": "string",
                      "description": "The version of the dataview corresponding to a given changeset.",
                      "nested_items": []
                    },
                    {
                      "name": "changesetId",
                      "type": "string",
                      "description": "A unique identifier for the changeset.",
                      "nested_items": []
                    },
                    {
                      "name": "segmentConfigurations",
                      "type": "list",
                      "description": "The db path and volume configuration for the segmented database.",
                      "nested_items": [
                        {
                          "name": "",
                          "type": "dict",
                          "description": "",
                          "nested_items": [
                            {
                              "name": "dbPaths",
                              "type": "list",
                              "description": "The database path of the data that you want to place on each selected volume for the segment. Each segment must have a unique database path for each volume.",
                              "nested_items": [
                                {
                                  "name": "",
                                  "type": "string",
                                  "description": "(string) ---",
                                  "nested_items": []
                                }
                              ]
                            },
                            {
                              "name": "volumeName",
                              "type": "string",
                              "description": "The name of the volume where you want to add data.",
                              "nested_items": []
                            },
                            {
                              "name": "onDemand",
                              "type": "boolean",
                              "description": "Enables on-demand caching on the selected database path when a particular file or a column of the database is accessed. When on demand caching is True, dataviews perform minimal loading of files on the filesystem as needed. When it is set to False, everything is cached. The default value is False.",
                              "nested_items": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "cacheStorageConfigurations",
          "type": "list",
          "description": "The configurations for a read only cache storage associated with a cluster. This cache will be stored as an FSx Lustre that reads from the S3 store.",
          "nested_items": [
            {
              "name": "",
              "type": "dict",
              "description": "",
              "nested_items": [
                {
                  "name": "type",
                  "type": "string",
                  "description": "The type of cache storage. The valid values are:",
                  "nested_items": [
                    {
                      "name": "",
                      "type": "",
                      "description": "CACHE_1000 --- This type provides at least 1000 MB/s disk access throughput.",
                      "nested_items": []
                    },
                    {
                      "name": "",
                      "type": "",
                      "description": "CACHE_250 --- This type provides at least 250 MB/s disk access throughput.",
                      "nested_items": []
                    },
                    {
                      "name": "",
                      "type": "",
                      "description": "CACHE_12 --- This type provides at least 12 MB/s disk access throughput.",
                      "nested_items": []
                    }
                  ]
                },
                {
                  "name": "size",
                  "type": "integer",
                  "description": "The size of cache in Gigabytes.",
                  "nested_items": []
                }
              ]
            }
          ]
        },
        {
          "name": "autoScalingConfiguration",
          "type": "dict",
          "description": "The configuration based on which FinSpace will scale in or scale out nodes in your cluster.",
          "nested_items": [
            {
              "name": "minNodeCount",
              "type": "integer",
              "description": "The lowest number of nodes to scale. This value must be at least 1 and less than the maxNodeCount. If the nodes in a cluster belong to multiple availability zones, then minNodeCount must be at least 3.",
              "nested_items": []
            },
            {
              "name": "maxNodeCount",
              "type": "integer",
              "description": "The highest number of nodes to scale. This value cannot be greater than 5.",
              "nested_items": []
            },
            {
              "name": "autoScalingMetric",
              "type": "string",
              "description": "The metric your cluster will track in order to scale in and out. For example, CPU_UTILIZATION_PERCENTAGE is the average CPU usage across all the nodes in a cluster.",
              "nested_items": []
            },
            {
              "name": "metricTarget",
              "type": "float",
              "description": "The desired value of the chosen autoScalingMetric. When the metric drops below this value, the cluster will scale in. When the metric goes above this value, the cluster will scale out. You can set the target value between 1 and 100 percent.",
              "nested_items": []
            },
            {
              "name": "scaleInCooldownSeconds",
              "type": "float",
              "description": "The duration in seconds that FinSpace will wait after a scale in event before initiating another scaling event.",
              "nested_items": []
            },
            {
              "name": "scaleOutCooldownSeconds",
              "type": "float",
              "description": "The duration in seconds that FinSpace will wait after a scale out event before initiating another scaling event.",
              "nested_items": []
            }
          ]
        },
        {
          "name": "clusterDescription",
          "type": "string",
          "description": "A description of the cluster.",
          "nested_items": []
        },
        {
          "name": "capacityConfiguration",
          "type": "dict",
          "description": "A structure for the metadata of a cluster. It includes information like the CPUs needed, memory of instances, and number of instances.",
          "nested_items": [
            {
              "name": "nodeType",
              "type": "string",
              "description": "The type that determines the hardware of the host computer used for your cluster instance. Each node type offers different memory and storage capabilities. Choose a node type based on the requirements of the application or software that you plan to run on your instance.",
              "nested_items": [
                {
                  "name": "",
                  "type": "",
                  "description": "kx.s.large --- The node type with a configuration of 12 GiB memory and 2 vCPUs.",
                  "nested_items": []
                },
                {
                  "name": "",
                  "type": "",
                  "description": "kx.s.xlarge --- The node type with a configuration of 27 GiB memory and 4 vCPUs.",
                  "nested_items": []
                },
                {
                  "name": "",
                  "type": "",
                  "description": "kx.s.2xlarge --- The node type with a configuration of 54 GiB memory and 8 vCPUs.",
                  "nested_items": []
                },
                {
                  "name": "",
                  "type": "",
                  "description": "kx.s.4xlarge --- The node type with a configuration of 108 GiB memory and 16 vCPUs.",
                  "nested_items": []
                },
                {
                  "name": "",
                  "type": "",
                  "description": "kx.s.8xlarge --- The node type with a configuration of 216 GiB memory and 32 vCPUs.",
                  "nested_items": []
                },
                {
                  "name": "",
                  "type": "",
                  "description": "kx.s.16xlarge --- The node type with a configuration of 432 GiB memory and 64 vCPUs.",
                  "nested_items": []
                },
                {
                  "name": "",
                  "type": "",
                  "description": "kx.s.32xlarge --- The node type with a configuration of 864 GiB memory and 128 vCPUs.",
                  "nested_items": []
                }
              ]
            },
            {
              "name": "nodeCount",
              "type": "integer",
              "description": "The number of instances running in a cluster.",
              "nested_items": []
            }
          ]
        },
        {
          "name": "releaseLabel",
          "type": "string",
          "description": "A version of the FinSpace managed kdb to run.",
          "nested_items": []
        },
        {
          "name": "vpcConfiguration",
          "type": "dict",
          "description": "Configuration details about the network where the Privatelink endpoint of the cluster resides.",
          "nested_items": [
            {
              "name": "vpcId",
              "type": "string",
              "description": "The identifier of the VPC endpoint.",
              "nested_items": []
            },
            {
              "name": "securityGroupIds",
              "type": "list",
              "description": "The unique identifier of the VPC security group applied to the VPC endpoint ENI for the cluster.",
              "nested_items": [
                {
                  "name": "",
                  "type": "string",
                  "description": "(string) ---",
                  "nested_items": []
                }
              ]
            },
            {
              "name": "subnetIds",
              "type": "list",
              "description": "The identifier of the subnet that the Privatelink VPC endpoint uses to connect to the cluster.",
              "nested_items": [
                {
                  "name": "",
                  "type": "string",
                  "description": "(string) ---",
                  "nested_items": []
                }
              ]
            },
            {
              "name": "ipAddressType",
              "type": "string",
              "description": "The IP address type for cluster network configuration parameters. The following type is available:",
              "nested_items": [
                {
                  "name": "",
                  "type": "",
                  "description": "IP_V4 --- IP address version 4",
                  "nested_items": []
                }
              ]
            }
          ]
        },
        {
          "name": "initializationScript",
          "type": "string",
          "description": "Specifies a Q program that will be run at launch of a cluster. It is a relative path within .zip file that contains the custom code, which will be loaded on the cluster. It must include the file name itself. For example, somedir/init.q.",
          "nested_items": []
        },
        {
          "name": "commandLineArguments",
          "type": "list",
          "description": "Defines the key-value pairs to make them available inside the cluster.",
          "nested_items": [
            {
              "name": "",
              "type": "dict",
              "description": "",
              "nested_items": [
                {
                  "name": "key",
                  "type": "string",
                  "description": "The name of the key.",
                  "nested_items": []
                },
                {
                  "name": "value",
                  "type": "string",
                  "description": "The value of the key.",
                  "nested_items": []
                }
              ]
            }
          ]
        },
        {
          "name": "",
          "type": "dict",
          "description": "",
          "nested_items": [
            {
              "name": "s3Bucket",
              "type": "string",
              "description": "A unique name for the S3 bucket.",
              "nested_items": []
            },
            {
              "name": "s3Key",
              "type": "string",
              "description": "The full S3 path (excluding bucket) to the .zip file. This file contains the code that is loaded onto the cluster when it's started.",
              "nested_items": []
            },
            {
              "name": "s3ObjectVersion",
              "type": "string",
              "description": "The version of an S3 object.",
              "nested_items": []
            }
          ]
        },
        {
          "name": "executionRole",
          "type": "string",
          "description": "An IAM role that defines a set of permissions associated with a cluster. These permissions are assumed when a cluster attempts to access another cluster.",
          "nested_items": []
        },
        {
          "name": "lastModifiedTimestamp",
          "type": "datetime",
          "description": "The last time that the cluster was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.",
          "nested_items": []
        },
        {
          "name": "savedownStorageConfiguration",
          "type": "dict",
          "description": "The size and type of the temporary storage that is used to hold data during the savedown process. This parameter is required when you choose clusterType as RDB. All the data written to this storage space is lost when the cluster node is restarted.",
          "nested_items": [
            {
              "name": "type",
              "type": "string",
              "description": "The type of writeable storage space for temporarily storing your savedown data. The valid values are:",
              "nested_items": [
                {
                  "name": "",
                  "type": "",
                  "description": "SDS01 --- This type represents 3000 IOPS and io2 ebs volume type.",
                  "nested_items": []
                }
              ]
            },
            {
              "name": "size",
              "type": "integer",
              "description": "The size of temporary storage in gibibytes.",
              "nested_items": []
            },
            {
              "name": "volumeName",
              "type": "string",
              "description": "The name of the kdb volume that you want to use as writeable save-down storage for clusters.",
              "nested_items": []
            }
          ]
        },
        {
          "name": "azMode",
          "type": "string",
          "description": "The number of availability zones you want to assign per cluster. This can be one of the following.",
          "nested_items": [
            {
              "name": "",
              "type": "",
              "description": "SINGLE --- Assigns one availability zone per cluster.",
              "nested_items": []
            },
            {
              "name": "",
              "type": "",
              "description": "MULTI --- Assigns all the availability zones per cluster.",
              "nested_items": []
            }
          ]
        },
        {
          "name": "availabilityZoneId",
          "type": "string",
          "description": "The availability zone identifiers for the requested regions.",
          "nested_items": []
        },
        {
          "name": "createdTimestamp",
          "type": "datetime",
          "description": "The timestamp at which the cluster was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.",
          "nested_items": []
        },
        {
          "name": "scalingGroupConfiguration",
          "type": "dict",
          "description": "The structure that stores the configuration details of a scaling group.",
          "nested_items": [
            {
              "name": "scalingGroupName",
              "type": "string",
              "description": "A unique identifier for the kdb scaling group.",
              "nested_items": []
            },
            {
              "name": "memoryLimit",
              "type": "integer",
              "description": "An optional hard limit on the amount of memory a kdb cluster can use.",
              "nested_items": []
            },
            {
              "name": "memoryReservation",
              "type": "integer",
              "description": "A reservation of the minimum amount of memory that should be available on the scaling group for a kdb cluster to be successfully placed in a scaling group.",
              "nested_items": []
            },
            {
              "name": "nodeCount",
              "type": "integer",
              "description": "The number of kdb cluster nodes.",
              "nested_items": []
            },
            {
              "name": "cpu",
              "type": "float",
              "description": "The number of vCPUs that you want to reserve for each node of this kdb cluster on the scaling group host.",
              "nested_items": []
            }
          ]
        }
      ]
    }
  ]
}